/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     | Website:  https://openfoam.org
    \\  /    A nd           | Copyright (C) 2011-2018 OpenFOAM Foundation
     \\/     M anipulation  |
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

    OpenFOAM is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.

Class
    Foam::myParCalcs

Description
    Creates particle/parcel calculation fields on the carrier/eulerian phase
    
    Summation calculations are performed during postMove() where vals are reset to zero each full set of iterations
    by preEvolve(). Vals are also reset to zero during postMove() if the list of particles/parcels is detected to 
    start over before a new call to preEvolve(). Final single time calculations are done during postEvolve().
    Values are written at calls to write() which are done at each simulation write time.
    Because postMove() is called multiple times for a single particle/parcel before moving on to the next particle/parcel,
    the summation calculations are done in such a way that they only do the summations over the final timestep 
    a given particle/parcel moves.
    
    Calculated values include number of particles, volume of particles, mass of particles, number density, volume fraction, 
    mass fraction, and filled cell volume for each eulerian grid cell.
    Time averaged and normalized versions of these values are also possible, but I decided not to implement them.
    It is also possible to do a per species or per injection form of each of these variables, I wanted to do this but in the end
    I decided it would be best to start simple with doing it over all the particles together 
     as total properties instead of as per species properties.
     Even that was a bit tough without accessing the individual injector information directly.
    
    
    Turns out that the calculations of nParTotal_, volTotal_, and massTotal_ are complicated, the injector information exists in the inherited
    cloud at constructor time, but the data for the injections are not filled until later. Means the timing of some calculations
    must change to compensate for some of the containers being empty at constructor time.
    
    It also turns out that the calculations of nParTotal_, volTotal_, and massTotal_ depend on injector information that is not consistent
    amongst injections AT ALL. I tried looking for various workarounds, and finally came to the conclusion that it was too much work or not
    possible with the current code organization to do methods that depend on the injections, without making the injection types way more consistent
    So with this latest update to the total calculations, myParCalcs CANNOT be used with the regular OpenFOAM provided injections,
    or any other user generated injections, unless they follow the rules of consistency required by myParCalcs. So far, only the OpenFOAM
    provided coneInjection doesn't follow these rules of consistency, cellZoneInjection, patchInjection, and manualInjection seem useable
    without making a modified version, but this is just a subset of the OpenFOAM provided injections. When an OpenFOAM injection does not
    follow these rules of consistency, it is up to the user of myParCalcs to make a copied and modified version,
    following the rules of consistency required by myParCalcs. Usually is good to take the copy and add a "my" in front of it,
    an example is coneInjection, it becomes myConeInjection.
    The rules of consistency are as follows:

        1) need to make sure a private sizeDistribution() is held within the injection, that can be generated by myParCalcs using a call to 
           coeffDict().subDict("sizeDistribution")
            
            I was originally going to try to setup a function that sampled or got the particle/parcel diameter, but this is not 
            possible without messing with the flowRateProfile_, volumeTotal_, and volumeToInject() methods for per time releases.
            The flowRateProfile_, volumeTotal_, and volumeToInject() are consistent with each other for a given injection, but they
            are NOT consistent with nPar and parcelsToInject() without a rework of the flowRateProfile_, volumeTotal_, and volumeToInject()
            methods for per time releases.
            So it is better not to mess with how diameters are selected, just return a reference to a copy of the size distribution.
            
            Turns out that trying to add a public accessor function to each injection type does not work either, because the typename of
            a given injection type is not given, and accessing public non-virtual functions of the inheriting injection types requires a reference
            to a type of the injection (as best I can tell). Writing a new myInjectionModel seems like too much work, so I decided that just
            constructing the sizeDistribution again from the dict referenced by a given injection type would be easier.

        2) need to modify parcelsToInject() to be consistent and able to be used at any simulation time. This means that you can put in the
           startTime() and endTime() returned by the injection without the parcelsToInject() spitting out fewer particles/parcels
           than it should. This requires making sure startTime() and endTime() are consistent with the method of parcelsToInject().
            
            The alternative to this would be making each injection type have the parcelsPerSecond and duration existing and correctly calculated.
            Those are the per time release variables, but making them a permanently calculated variable each injection could be useful.
            Well, parcelsToInject() already performs this way, and can be better controlled.
    
        I originally also wanted to make volumeToInject() consistent with parcelsToInject(), but as described in 1), that is NOT a good idea
        until flow rate profiles are used, in which case a rework of the flow rate profile method for ALL injection types would be required.
        Fortunately, each of the injection types I have used so far each have a sizeDistribution within them, this method would break down badly
        if a sizeDistribution were not within the code, would have to try changing all the injection types to do a diameter calling function instead,
        which would require dealing with the flowRateProfile_, volumeTotal_, and volumeToInject() methods and would be a pain.
    
    Unfortunately, postMove() cannot detect when it has reached the final timestep of the final particle/parcel, 
    just the final timestep of all other particles/parcels. This would cause an off by one particle/parcel
    for all the counts. But because postEvolve() is always called after the final timestep of the final particle/parcel, but
    before the next reset of the particle/parcel pastIter_ values, this summation calculation for the final timestep of the
    final particle/parcel is done in postEvolve() before the final single calculations within postEvolve(). This stops the
    off by one problem. This part of the algorythm is extra quirky, but necessary.
    
    It may be possible to do a much simpler method/algorythm for the summation calculations, but it would require accessing 
    the timestep fraction information (a form of the iteration information) for a given particle/parcel using calls to 
    this->owner(), which are complicated. It also seems strange, normal functions just pass in additional information directly
    rather than having the programmer access the full code that is calling the function from within the function.
    

SourceFiles
    myParCalcs.C

\*---------------------------------------------------------------------------*/

#ifndef myParCalcs_H
#define myParCalcs_H

#include "CloudFunctionObject.H"
#include "volFields.H"

#include "distributionModel.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

namespace Foam
{

/*---------------------------------------------------------------------------*\
                       Class myParCalcs Declaration
\*---------------------------------------------------------------------------*/

template<class CloudType>
class myParCalcs
:
    public CloudFunctionObject<CloudType>
{
    // Private Data

        // Typedefs

            //- Convenience typedef for parcel type
            typedef typename CloudType::parcelType parcelType;

        
        // calculated val data pointers
        
            //- particle count, the number of particles counted for a given eulerian grid cell
            autoPtr<volScalarField> dataPtr_numPar;
            
            //- volume count, the amount of volume of particles counted for a given eulerian grid cell
            autoPtr<volScalarField> dataPtr_volPar;
            
            //- mass count, the amount of mass of particles counted for a given eulerian grid cell
            autoPtr<volScalarField> dataPtr_massPar;
            
            //- number density, number of particles counted for a given eulerian grid cell divided by the total number of particles to be released over the simulation
            autoPtr<volScalarField> dataPtr_numDensity;
            
            //- volume fraction, particle volume divided by total particle volume
            autoPtr<volScalarField> dataPtr_volFrac;
            
            //- mass fraction, particle mass divided by the total mass of all particles to be released over the simulation
            autoPtr<volScalarField> dataPtr_massFrac;
            
            //- volume fraction, but of particle volume divided by cell volume instead of by total particle volume, the space filled by particles in a given eulerian grid cell
            autoPtr<volScalarField> dataPtr_cellFillSpace;

        // total calculation variables
        // note that these are estimates unless the injection types are made way more consistent within parcelsToInject(), parcelsToInject() sometimes does numerical
        // rounding, multiplying, or dividing, that can cause numbers to not add up when doing totals at once compared to totals slowly added over each timestep
        // worse, they sometimes depend on random number stuff, so the results should be close, but may or may not be consistent with the actual total used
        // at simulation time. But it should be close enough.
            
            //- boolean used to force calculation of the total variables to only happen once, even though the lines of code that will do the calculation
            //- have to be placed where they would normally be called at each iteration. This is required because the necessary injector storage containers
            //- exist at constructor time, but are empty till after constructor time
            //- this starts out with a value of TRUE using the constructor initializer lists, it gets set to FALSE when the total variables are calculated
            //- and stays as FALSE for the remainder of the simulation
            bool calcTotals_;
            
            //- the calculated total number of particles/parcels to be released by all injections over the time of the entire simulation
            scalar nParTotal_;
            
            //- the calculated total volume to be released by all injections over the time of the entire simulation
            scalar volTotal_;
            
            //- the calculated total mass to be released by all injections over the time of the entire simulation
            scalar massTotal_;
        
        // postMove() particle/parcel iteration variables and iteration temporary values
            
            //- the origId from the last iteration, used to tell when switching from one particle/parcel to another
            scalar pastIter_origId;
            
            //- the cell index from the last iteration, when switching from one particle/parcel to another it is used to store 
            //- the pastIter_ values to the correct pastIter_ eulerian grid cell location 
            label pastIter_cellIdx;
            
            //- temporary numPar summation value from the last iteration, added to the storage of the actual value when switching from one particle/parcel to another
            scalar pastIter_numPar;
            
            //- temporary volPar summation value from the last iteration, added to the storage of the actual value when switching from one particle/parcel to another
            scalar pastIter_volPar;
            
            //- temporary massPar summation value from the last iteration, added to the storage of the actual value when switching from one particle/parcel to another
            scalar pastIter_massPar;
            
            //- temporary numDensity summation value from the last iteration, added to the storage of the actual value when switching from one particle/parcel to another
            scalar pastIter_numDensity;
            
            //- temporary volFrac summation value from the last iteration, added to the storage of the actual value when switching from one particle/parcel to another
            scalar pastIter_volFrac;
            
            //- temporary massFrac summation value from the last iteration, added to the storage of the actual value when switching from one particle/parcel to another
            scalar pastIter_massFrac;
            
            //- temporary cellFillSpace summation value from the last iteration, added to the storage of the actual value when switching from one particle/parcel to another
            scalar pastIter_cellFillSpace;
        
    // Private Member Functions
        
        // total calculation functions
        
            //- function for calculating the nParsTotal, volumeTotal, and massTotal from all the individual injectors
            // This is kind of a complex function, probably start by just setting the desired vals to a default value
            // 
            // HOW ANNOYING. This would normally be called at constructor time, but the containers holding the injector
            // information don't get filled until AFTER constructor time, meaning this will end up having to be called at
            // each iteration, probably using preEvolve(), whether the information needs calculated more frequently than one time
            // or not. I could see it needing to be updated at each new time anyways depending on how the totals are used,
            // but having a single total calculated at the beginning of the simulation is better, so probably will need to 
            // use a bool or something to force it to only be called once, even though it will have to be placed in a function
            // that is called at every iteration.
            void calc_totalVals();
        
        // other functions
            
            //- function for resetting the values of everything at new iteration loops
            // called during preEvolve() each time it is called, called during postMove() each time it is detected that the 
            // iteration loop starts over before calls to preEvolve()
            void resetVars();
            
            
protected:

    // Protected Member Functions

        //- Write post-processing info
        virtual void write();
        
        //- function for initializing data for data pointers, called at constructor time
        // this function holds information useful to understanding where write() will write data
        void initializeDataPointers();


public:

    //- Runtime type information
    TypeName("myParCalcs");


    // Constructors

        //- Construct from dictionary
        myParCalcs
        (
            const dictionary& dict,
            CloudType& owner,
            const word& modelName
        );

        //- Construct copy
        myParCalcs(const myParCalcs<CloudType>& vf);

        //- Construct and return a clone
        virtual autoPtr<CloudFunctionObject<CloudType>> clone() const
        {
            return autoPtr<CloudFunctionObject<CloudType>>
            (
                new myParCalcs<CloudType>(*this)
            );
        }


    //- Destructor
    virtual ~myParCalcs();


    // Member Functions

        // Evaluation

            //- Pre-evolve hook
            virtual void preEvolve();

            //- Post-move hook
            virtual void postMove
            (
                parcelType& p,
                const scalar dt,
                const point& position0,
                bool& keepParticle
            );
            
            //- Post-evolve hook
            virtual void postEvolve();
};


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

} // End namespace Foam

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

#ifdef NoRepository
    #include "myParCalcs.C"
#endif

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

#endif

// ************************************************************************* //
